%{
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include "handler.hpp" // Contains all the class definitions
#include <stack>

int yylex();
void yyerror(const char* s);
extern int yylineno;  // Needed to track line numbers

// Global objects
extern BlockNode* currBlock;
// Stack to keep track of loop labels for break statements
std::vector<std::string> loopEndLabels;

// Global variables for function parameter and argument handling
std::vector<std::pair<std::string, std::string>> currentParameters;
std::vector<std::unique_ptr<ASTNode>> currentArguments;
std::vector<std::pair<std::unique_ptr<ASTNode>, std::unique_ptr<BlockNode>>> caseExpressions;
std::unique_ptr<BlockNode> defaultBlock = nullptr;

std::string curr_function_name = "";
std::string curr_function_type = "";
bool curr_func_return_shown = false;
bool function_declared = false;
int end_lable_num = 0;
std::stack<std::string> endLabelsStack;
// Helper function to clear parameter list
void clearParameters() {
    currentParameters.clear();
}

// Helper function to add a parameter
void addParameter(const std::string& type, const std::string& name) {
    currentParameters.push_back(std::make_pair(type, name));
}

// Helper function to get and clear arguments
std::vector<std::unique_ptr<ASTNode>> getAndClearArguments() {
    std::vector<std::unique_ptr<ASTNode>> args;
    args.swap(currentArguments);
    return args;
}

%}

%union {
    std::string* strVal;
    ASTNode* node;
    BlockNode* blockNode;
    int intVal;
    float floatVal;
    bool boolVal;
    char charVal;
}

%token <strVal> IDENTIFIER STRING_VALUE
%token <charVal> CHAR_VALUE  
%token <intVal> INT_VALUE
%token <floatVal> FLOAT_VALUE
%token <boolVal> BOOL_VALUE

%type <node> EXPRESSION
%type <strVal> TYPE
%type <node> STATEMENT 
            DECLARATION_STATEMENT 
            ASSIGNMENT_STATEMENT 
            PRINT_STATEMENT 
            IF_STATEMENT 
            IF_TAIL 
            WHILE_STATEMENT 
            DO_WHILE_STATEMENT 
            FOR_STATEMENT 
            FUNC_CALL 
            FUNC_DECLARATION_STATEMENT 
            RETURN_STATEMENT 
            SWITCH_STATEMENT
            BREAK_STATEMENT
            CASE_ITEM
%type <blockNode> BLOCK
%type <node> PROGRAM


%token INT FLOAT STRING CHAR BOOL VOID 
%token PRINT RETURN 
%token LOGICAL_AND LOGICAL_OR LOGICAL_NOT
%token EQUAL NOT_EQUAL
%token GT LT GTE LTE EQ
%token SEMICOLON MOD ADD SUB MUL DIV POW BITWISE_OR BITWISE_AND SHL SHR
%token SWITCH BREAK CASE DEFAULT IF ELSE FOR WHILE DO

%right EQ
%left LOGICAL_OR
%left LOGICAL_AND
%left BITWISE_OR
%left BITWISE_AND
%left EQUAL NOT_EQUAL
%left GT LT GTE LTE
%left SHL SHR
%left ADD SUB
%left MUL DIV MOD
%right POW
%right LOGICAL_NOT

%%
PROGRAM:
        PROGRAM STATEMENT  { 
            if ($2 != nullptr) {
                currBlock->addStatement(std::unique_ptr<ASTNode>($2)); 
            }
            $$ = nullptr;
        }        
        | { $$ = nullptr; }
        ;

//________________________________________________ BLOCK ________________________________________________
BLOCK:
        '{' {
            // Create a new block with the current block as parent
            BlockNode* newBlock = new BlockNode(currBlock ? currBlock->getId() + 1 : 0, currBlock);
            currBlock = newBlock;
        } PROGRAM '}' {
            // Set the result to the current block
            $$ = currBlock;
            // Restore parent block
            currBlock = currBlock->getParent();
        }
        ;

//________________________________________________ STATEMENT ________________________________________________
STATEMENT:
        DECLARATION_STATEMENT { $$ = $1; }
        | ASSIGNMENT_STATEMENT { $$ = $1; }
        | EXPRESSION SEMICOLON { $$ = $1; }
        | IF_STATEMENT { $$ = $1; }
        | WHILE_STATEMENT { $$ = $1; } 
        | DO_WHILE_STATEMENT { $$ = $1; }
        | FOR_STATEMENT { $$ = $1; }
        | BREAK_STATEMENT { $$ = $1; }
        | EXPRESSION { $$ = $1; }
        | PRINT_STATEMENT { $$ = $1; }
        | BLOCK { $$ = $1; }
        | RETURN_STATEMENT SEMICOLON { $$ = $1; }
        | FUNC_DECLARATION_STATEMENT { $$ = $1; }
        | SWITCH_STATEMENT { $$ = $1; }
        ;

//________________________________________________ PRINT STATEMENT ________________________________________________
PRINT_STATEMENT:
        PRINT '(' EXPRESSION ')' SEMICOLON {
            $$ = new PrintNode(std::unique_ptr<ASTNode>($3));
        }
        ;

//________________________________________________ TYPE ________________________________________________
TYPE:
        INT         { $$ = new std::string("int");   }
        | FLOAT     { $$ = new std::string("float"); }
        | BOOL      { $$ = new std::string("bool");  }
        | STRING    { $$ = new std::string("string");}
        | CHAR      { $$ = new std::string("char");  }
        | VOID      { $$ = new std::string("void");  }
        ;

//________________________________________________ EXPRESSION ________________________________________________
EXPRESSION:
        IDENTIFIER    { $$ = new IdentifierNode(*$1, currBlock, yylineno); delete $1; }        
        | INT_VALUE   { $$ = new LiteralNode("int", std::to_string($1)); }       
        | FLOAT_VALUE { $$ = new LiteralNode("float", std::to_string($1)); }         
        | BOOL_VALUE  { $$ = new LiteralNode("bool", $1 ? "true" : "false"); }
        | STRING_VALUE { $$ = new LiteralNode("string", *$1); delete $1; }        
        | CHAR_VALUE  { $$ = new LiteralNode("char", std::string(1, $1)); } 
        
        | '(' EXPRESSION ')'  { $$ = $2; }
        
        | FUNC_CALL { $$ = $1; }

        | SUB EXPRESSION { 
            $$ = new UnaryOpNode("-", std::unique_ptr<ASTNode>($2), yylineno);
        }          
        | LOGICAL_NOT EXPRESSION {
            $$ = new UnaryOpNode("!", std::unique_ptr<ASTNode>($2), yylineno);
        }

        | EXPRESSION ADD EXPRESSION {
            $$ = new BinaryOpNode("+", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION SUB EXPRESSION {
            $$ = new BinaryOpNode("-", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }           
        | EXPRESSION MUL EXPRESSION {
            $$ = new BinaryOpNode("*", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }          
        | EXPRESSION DIV EXPRESSION {
            $$ = new BinaryOpNode("/", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }           
        | EXPRESSION POW EXPRESSION {
            $$ = new BinaryOpNode("^", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION MOD EXPRESSION {
            $$ = new BinaryOpNode("%", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }         
        
        | EXPRESSION LOGICAL_OR EXPRESSION {
            $$ = new BinaryOpNode("||", std::unique_ptr<ASTNode>($1), 
                                  std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION LOGICAL_AND EXPRESSION {
            $$ = new BinaryOpNode("&&", std::unique_ptr<ASTNode>($1), 
                                  std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION BITWISE_OR EXPRESSION {
            $$ = new BinaryOpNode("|", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION BITWISE_AND EXPRESSION {
            $$ = new BinaryOpNode("&", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION SHL EXPRESSION {
            $$ = new BinaryOpNode("<<", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION SHR EXPRESSION {
            $$ = new BinaryOpNode(">>", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }

        | EXPRESSION EQUAL EXPRESSION {
            $$ = new BinaryOpNode("==", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }  
        | EXPRESSION NOT_EQUAL EXPRESSION {
            $$ = new BinaryOpNode("!=", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        } 

        | EXPRESSION GT EXPRESSION {
            $$ = new BinaryOpNode(">", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION LT EXPRESSION {
            $$ = new BinaryOpNode("<", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }             
        | EXPRESSION GTE EXPRESSION {
            $$ = new BinaryOpNode(">=", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        | EXPRESSION LTE EXPRESSION {
            $$ = new BinaryOpNode("<=", std::unique_ptr<ASTNode>($1), 
                                 std::unique_ptr<ASTNode>($3), yylineno);
        }
        ;               

//________________________________________________ IF STATEMENT ________________________________________________
IF_TAIL: 
        ELSE BLOCK {
            $$ = $2;
        }
        | ELSE IF_STATEMENT {
            $$ = $2;
        }
        | {
            $$ = nullptr;
        }
        ;

IF_STATEMENT:
        IF '(' EXPRESSION ')' BLOCK IF_TAIL {
            $$ = new IfNode(std::unique_ptr<ASTNode>($3), std::unique_ptr<BlockNode>($5), std::unique_ptr<ASTNode>($6), yylineno);
        }
        ;

//________________________________________________ WHILE STATEMENT ________________________________________________
WHILE_STATEMENT:
        WHILE { 
            endLabelsStack.push("while_" + std::to_string(end_lable_num) + "_end"); 
            end_lable_num++; } '(' EXPRESSION ')' BLOCK {
            $$ = new WhileNode(std::unique_ptr<ASTNode>($4), 
                              std::unique_ptr<BlockNode>($6), 
                              endLabelsStack.top(),
                              yylineno);
            endLabelsStack.pop();
        } 
        ;

//________________________________________________ DO WHILE STATEMENT ________________________________________________
DO_WHILE_STATEMENT:
        DO { 
            endLabelsStack.push("do_while_" + std::to_string(end_lable_num) + "_end"); 
            end_lable_num++; } BLOCK WHILE '(' EXPRESSION ')' SEMICOLON {
            $$ = new DoWhileNode(std::unique_ptr<BlockNode>($3), 
                                std::unique_ptr<ASTNode>($6), 
                                endLabelsStack.top(),
                                yylineno);
            endLabelsStack.pop();
        }
        ;

//________________________________________________ FOR STATEMENT ________________________________________________
FOR_STATEMENT:
    FOR '(' {
        // Create a new block for the for loop (both parentheses statements and body)
        BlockNode* newBlock = new BlockNode(currBlock ? currBlock->getId() + 1 : 0, currBlock);
        currBlock = newBlock;
        endLabelsStack.push("for_" + std::to_string(end_lable_num) + "_end"); end_lable_num++;
    } 
    STATEMENT STATEMENT STATEMENT ')' 
    // Note: We don't create a new block here since we'll use the block we already created
    '{' PROGRAM '}' {
        // Store the for loop statements
        std::unique_ptr<ASTNode> initStmt($4);
        std::unique_ptr<ASTNode> condStmt($5);
        std::unique_ptr<ASTNode> updateStmt($6);
        
        // Use the current block for the body
        BlockNode* bodyBlock = currBlock;
        
        // Restore parent block
        currBlock = currBlock->getParent();
        
        // Create the ForNode
        $$ = new ForNode(std::move(initStmt), 
                         std::move(condStmt), 
                         std::move(updateStmt), 
                         std::unique_ptr<BlockNode>(bodyBlock), 
                         endLabelsStack.top(),
                         yylineno);
        endLabelsStack.pop();
    }
    ;

//________________________________________________ SWITCH STATEMENT ________________________________________________
SWITCH_STATEMENT:
    SWITCH {
        // Clear previous case collections
        caseExpressions.clear();
        defaultBlock = nullptr;
        
        // Push the end label for the switch (used by break statements)
        endLabelsStack.push("switch_" + std::to_string(end_lable_num) + "_end"); 
        end_lable_num++;
    } '(' EXPRESSION ')' '{' CASES '}' {
        // Create the switch node with collected cases
        $$ = new SwitchNode(std::unique_ptr<ASTNode>($4), 
                           std::move(caseExpressions), 
                           std::move(defaultBlock),
                           endLabelsStack.top(),
                           yylineno);
        endLabelsStack.pop();
    }
    ;

CASES:
    CASES CASE_ITEM
    | /* empty */
    ;

CASE_ITEM:
    CASE EXPRESSION ':' BLOCK {
        // Add case to the collection
        caseExpressions.push_back(std::make_pair(
            std::unique_ptr<ASTNode>($2),
            std::unique_ptr<BlockNode>($4)
        ));
        $$ = nullptr; // No need to return a value for this rule
    }
    | DEFAULT ':' BLOCK {
        if(defaultBlock != nullptr) {
            ErrorHandler::getInstance()->reportError("Default Case already exist", yylineno);
        }
        // Set default case
        defaultBlock = std::unique_ptr<BlockNode>($3);
        $$ = nullptr; // No need to return a value for this rule
    }
    ;

BREAK_STATEMENT:
        BREAK SEMICOLON { 
            if(!endLabelsStack.empty()) $$ = new BreakNode(endLabelsStack.top(), yylineno); 
            else ErrorHandler::getInstance()->reportError("Break outside of a loop", yylineno);
            }
        ;
        
//________________________________________________ FUNCTION CALL ________________________________________________
FUNC_CALL:
    IDENTIFIER '(' {
        // Clear the arguments vector before starting to collect arguments
        currentArguments.clear();
    } ARGUMENTS ')' {
        // Create the function call node with collected arguments
        $$ = new FunctionCallNode(*$1, getAndClearArguments(), currBlock, yylineno);
        delete $1;
    }
    ;       

ARGUMENTS:      
    EXPRESSION ',' {
        // Store the expression as an argument
        currentArguments.push_back(std::unique_ptr<ASTNode>($1));
    } ARGUMENTS 
    | EXPRESSION {
        // Store the last expression as an argument
        currentArguments.push_back(std::unique_ptr<ASTNode>($1));
    }
    | /* empty */ {
        // No arguments
    }
    ;

//________________________________________________ FUNCTION DECLARATION STATEMENT ________________________________________________

FUNC_DECLARATION_STATEMENT:
    TYPE IDENTIFIER '(' {
        // Clear parameters before collecting new ones
        curr_function_name = *$2;
        curr_function_type = *$1;
        function_declared = true;
        if(currBlock->getParent() != nullptr) {
            ErrorHandler::getInstance()->reportError("Function " + curr_function_name + " should be global", yylineno);
        }
        clearParameters();
    } ARGS ')' BLOCK {

        if(!curr_func_return_shown && curr_function_type != "void") {
            ErrorHandler::getInstance()->reportError("Function " + curr_function_name + " should return " + curr_function_type, yylineno);            
        }
        // Cre  ate the function declaration node with collected parameters
        $$ = new FunctionDeclarationNode(*$1, *$2, currentParameters, 
                                       std::unique_ptr<BlockNode>($7), 
                                       currBlock, yylineno);
        curr_func_return_shown = false;
        curr_function_name = "";
        curr_function_type = "";
        function_declared = false;
        delete $1;
        delete $2;
    };

ARGS:
    ARG_DECL ',' ARGS
    | ARG_DECL
    | /* empty */
    ;

ARG_DECL:
    TYPE IDENTIFIER {
        // Add parameter to the current parameter list
        addParameter(*$1, *$2);
        delete $1;
        delete $2;
    }
    ;

RETURN_STATEMENT:
    RETURN {
        if(!function_declared) {
            ErrorHandler::getInstance()->reportError("NO function has been declared", yylineno);
        }
        curr_func_return_shown = true;
        $$ = new ReturnNode(nullptr, currBlock, curr_function_type, yylineno);
    }
    | RETURN EXPRESSION {
        // Return with expression
        if(!function_declared) {
            ErrorHandler::getInstance()->reportError("NO function has been declared", yylineno);
        }
        curr_func_return_shown = true;

        $$ = new ReturnNode(std::unique_ptr<ASTNode>($2), currBlock, curr_function_type, yylineno);
    }
    ;        

//________________________________________________ ASSIGNMENT STATEMENT ________________________________________________
ASSIGNMENT_STATEMENT:
        IDENTIFIER EQ EXPRESSION SEMICOLON { 
            $$ = new AssignmentNode(*$1, std::unique_ptr<ASTNode>($3), currBlock, yylineno);
            delete $1;
        } 
        ;

//________________________________________________ DECLARATION STATEMENT ________________________________________________
DECLARATION_STATEMENT:
        TYPE IDENTIFIER EQ EXPRESSION SEMICOLON { 
            $$ = new DeclarationNode(*$1, *$2, false, std::unique_ptr<ASTNode>($4), currBlock, yylineno);
            delete $1;
            delete $2;
        }
        | TYPE IDENTIFIER SEMICOLON { 
            $$ = new DeclarationNode(*$1, *$2, false, nullptr, currBlock, yylineno);
            delete $1;
            delete $2;
        }
        ;

%%